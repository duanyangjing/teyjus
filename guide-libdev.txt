This is a guide for library developers who need to create λProlog
libraries from C programs. A λProlog "library" can be best conceptualized
as a module that has C programs as its implementation instead of a .mod
file. λProlog programmers should be able to integrate these libraries as
additional modules and use them just like native predicates.

There are two files one needs to create: one is a lambda program signature file
that defines the interface of the predicates available in this library; this
signature will later be incorporated into other user-defined modules. The other
file is the implementation of this signature as a compiled C shared
library. This C library should be extended from the original C program in order
to bridge the gap between data representation and calling convention between C
and λProlog.


Creating λProlog signature
---------------------------------
The signature file follows the same general structure as a regular λProlog
signature, but requires a little more information for the compiler to manage
external predicates. The required syntax is as follows:

sig <signame>.
#lib <clibname>.
extern type <lpname1> <cname1> <type1>.
...
extern type <lpnameN> <cnameN> <typeN>.
regcl <lpnames>.

The first line in this declaration sequence associates the name signame with
this signature; this name can be employed in other user-defined modules to
include the definitions in this signature. The second line indicates the
location of the C library code that implements the builtin functions that need
to be imported into the λProlog environment. This is followed by a sequence of
declarations that identify a collection of builtin predicates together with
their types and entry points that are ostensibly supported by the C library
code: in a declaration of the form

extern type <lpname> <cname> <type>

<lpname> stands for the name of the predicate that can be used in λProlog
programs, <cname> is a symbol that identifies the entry point and <type>
provides the type of the predicate. The last line in the signature file
identifies the subcollection of the predicates provided in this signature that
are “register clobbering.” The lpWAM uses argument registers for local
computations in a predicate invocation as well as for passing parameters to
predicates. In general, invocation of predicates can destroy the contents of an
existing register and the compiler has to therefore assume that the values in
argument registers will not be preserved across a call. However, it is useful to
know if a predicate will not destroy the values in argument registers: this
information can be utilized in allocating registers in a way that minimizes data
movement. This decision can be made based on what functions from the simulator
interface are being used to extend the original C code, which will be discussed
in the next section.


Creating C shared library object
--------------------------------
The original C program needs to be extended in several ways before it can be
properly called from the lpWAM. The procedure directly invoked by the simulator
will have to convert the arguments, which have the form of λProlog data, into a
representation suitable for C and, conversely, it would have to transform the
results obtained from the computation in C into the corresponding λProlog form;
we refer to these phases as the marshalling and unmarshalling of the data. A
typical function as entry point to the library should have the following
structure:

void cname()
{
  // call marshalling functions on arguments
  // invoke the actual C function
  // call unmarshalling functions on return of the C function
}

where cname is the symbol name that the simulator identifies as the entry point;
this name should be the same as the cname field in the type definition for a
external predicate predicate in the corresponding signature file. Marshalling
and unmarshalling functions are defined in a header file at
  source/simulator/cinterface.h
Here are the some examples of the functions available:

/* Get data from argument register i */
int TJ_getInt(int i);
float TJ_getReal(int i);
const char* TJ_getStr(int i);

/*
 * Unify the return value of a C function with an existing term at
 * argument i (the one that is to hold the return value).
 */
void TJ_returnInt(int i, int val);
void TJ_returnReal(int i, float val);
void TJ_returnStr(int i, char* s);

The get functions take lpWAM data from argument register i and transform them
into C representation. These functions should be called on all arguments. The
return functions takes C data and transform them into lpWAM representation, and
then unifies the term with the original term at argument position i. These
functions should be called on the return value with the argument position that
is supposed to hold the return value. The last argument is reserved for this
purpose.

Also functions that will result in destroying original values in argument
registers will be documented in this file. Typically all "return" functions
will have this behavior because in the end of these functions control is
usually transferred to the builtin unification procedure, which requires
rearranging the original argument registers.

An example:

int plus(int x, int y) { return x + y; }

void plus_wrapper()
{
  int x = TJ_getInt(1);
  int y = TJ_getInt(2);
  int ret = plus(x,y);
  TJ_returnInt(3, ret);
}

Finally the C code needs to be compiled into a shared library(.so file) that
is later dynamically linked with the simulator. Code can be compiled as:
  gcc -g -shared -fpic -o lib.so lib.c

In the end this shared library and the signature file should be delievered
to programmers to use together with their native code.
