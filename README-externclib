/lib/ contains a list of libraries I have made for testing purposes.

The other three libraries:
  arith.so - contains some math predicates
  str.so   - contains a predicate to reverse a string
  os.so    - contains the externalized getenv and system predicate from io.c

A note about streams - why other functions in io.c was not externalized
-----------------------------------------------------------------------
Teyjus maintains its own stream implementation. Adding support for the current
stream implementation in the simulator interface does not suit the spirit of the
interface very well.

One way to look at the problem is that the treatment of streams in builtins
usually involves first getting the stream object, and then manipulating the
stream by calling functions implemented on Teyjus streams. These functions
belong to the simulator, which are not independent C computation. This does not
fit into the model of the C interface, which requires an independent C
computation between the marshalling/unmarshalling procedures.

Here is another way to look at the problem: A Teyjus stream conceptually
represents a sequence of characters, possibly from either a file or a string. In
C we have FILE pointer which might correspond to a file stream, and a C string
which corresponds to a string stream, but there is no such an object that
provides an abstract view of both. More importantly, a stream is not just a file
pointer or a char pointer, it requires many other bookeeping about the data,
such as the allocated buffer, read/write offset, etc. And the manipulation of
these data is usually hidden from programmers - by calling the library
stdio.h. It's not recommended at all for a C programmer to directly manipulate a
FILE object. So under this context, suppose we want to expose a "stream for
file f from which we have read 5 characters"? We would need to create a FILE
pointer and manipulate its internal data to reflect the offset, which strongly
violates the practice of using a C FILE pointer. The only possible workaround
for this is to use the SAME device to manipulate a Teyjus file stream as to a C
FILE pointer, which is to read/write data using the stdio.h functions. In this
way we might be able to directly pass the FILE pointer around between Teyjus and
C, and allow programmers to manipulate in C a FILE pointer that has been created
and updated in Teyjus.

As a result all functions that involve streams are not externalized. All
functions except getenv and system in the original file builtins/io.c are
treated this way. Some io functions (like print) do not have streams as
arguments, but they directly manipulate the predefined streams such as std_in,
std_out, etc.


2. Four subsystems can be successfully built, including tjcc, tjlink, tjsim, tjdis.
tjdepend and tjparse do not compile for now, but should be easy to fix.

3. There seem to be warnings when code is first built, but they are not from the
code that I write.

4. There is one issue related to exposing symbols in dynamic symbol tables. According
to gcc's documentation, the flag -rdynamic would expose all symbols to the dynamic
symbol table, but it looks like in rare cases not all symbols are actually exposed...

One case was when the file "simulator/cinterface.c" is compiled and linked as part of the
simulator, all its functions are not put into the dynamic symbol table, however
having another part of the simulator call a function in this module (hence the
existence of the function noop()) would make the symbols show up.

The other case was in the module io.so. Three predicates, str_to_term, readterm,
and read are broken because the function "FRONT_RT_readTermAndType" that they call
cannot be located during dynamic linking. Examining the tjsim executable shows
that this symbol in not included in the dynamic symbol table. One way to get
around this is to use the same trick as above, but I'm leaving it as it is because
I'd like to try to find a more elegant solution. Right now it seems that this
problem shows up for those "standalone" functions - functions that are not being
called in any other parts of the tjsim executable.