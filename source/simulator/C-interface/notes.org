//------------------DF_Term------------------
typedef struct 
{
    Byte   categoryTag;
    Byte   mark;                    //to be used in garbage collection
} DF_Tag;

// a generic term (head) for every category
typedef struct               
{
    DF_Tag       tag;        /* the common field for every term (head); can 
                                be any one of enum TermCategory.
                                rely on struct alignment */
    Word         dummy;      /* a place holder which enforces the size of the 
                                generic term to be 2 words. */
} DF_Term;

typedef DF_Term *DF_TermPtr; //term pointer


//------------------DF_Type------------------
typedef struct               
{
    DF_Tag          tag;     /* the common field for every type (head); can 
                                be any one of enum TypeCategory.
                                rely on struct alignment */ 
    Word            dummy;   /* a place holder which enforces the size of the 
                                generic term to be 2 words. */
} DF_Type;

typedef DF_Type *DF_TypePtr;      //type pointer

//------------------primitive types-----------
typedef struct                  //integers
{
    DF_Tag        tag;     
    long int      value;
} DF_IntTerm;

typedef struct                  //floats
{
    DF_Tag        tag;     
    float         value;
} DF_FloatTerm;







// ----------------------------------
// absmachine datatype, a term or a type
typedef union  //the type of data: (atomic) term or type 
{
    DF_Term term;
    DF_Type type;
} AM_DataType;

typedef AM_DataType *AM_DataTypePtr;



//----------------------Exception handling----------------------
// setjmp(env:jmp_buf) ... longjmp(env) will jump to the point after setjmp
// keep a stack of jmp_buf as the stack of exceptions, modify the stack
// for each try/catch operation.

EM_error throws exception, modifies exception stack
    short analysis: relies on exception stack, cannot be externalized.
    also prints error message on stdout, which libraries do not know
    
    possible solution: set a jump point before calling external functions,
    pass the jmp_buf to external functions, all internal exceptions jump back
    to this point, OR let external functions return error code to communicate this information to the abstract machine. This might
    be doable but is not the interesting part of the project. Besides, in our
    model the library developer specify the right way to call the functions, and errors in miss-using the functions
    should be handled by in the library functions

printing error messages rely on struct messageBlock and MSG_Msg in message.h/message.c								
//--------------------------------------------------------------
// builtins can be externalized
// BICOMP_comp in compexp.c - need to call BIEVAL

// builtins can/should not be externalized
// BIMETA* in meta.c        - intrinsic, and relies heavily on interal states of AM
// BIEVAL* in evalexp.c     - intrinsic
1. evalexp is intrinsic
2. evalInt/float/string needs to call HN_hnorm, which modifies many AM regs, such as AM_hreg,
   AM_head, AM_rigFlag... Even if we do this before the dispatching process, the eval
   function still needs to access AM_head, AM_argVec, AM_rigFlag. For string related
   eval functions, it needs to access AM_hreg when allocating string on heap.
3. Conceptually the evaluation to int/float is the marshalling process itself. There
   is no sensible corresponding C computation that does evaluation after marshalling
   process.

BICOMP* in compexp.c - can be externalized, but probably shouldn't
1. Totally depends on eval functions. The marshalling process would be eval left and
   right operators. Then the corresponding C computation would be extremely simple -
   just compares two ints/floats. But because eval cannot be externalized, this cannot
   either.









								
//
openIn, openOut, openApp - calls doOpen
closeIn, closeOut
 
    doOpen, openStr - most of work is bindvartostream, which has to be done inside abstmachine.
    May choose to externalize the work before calling bindvartostream, but the work before is
    trivial to externalize.
    
    

// Builtins calling bindvartostream  -  allocate (and make) stream on heap, stores binding in trail
// Builtins calling bindvartostring  -  allocate (and make) string on heap, stores binding in trail
// Builtins calling bindvartoint     -  make int, stores binding in trail
static void BIIO_bindVarToInt(DF_TermPtr varPtr, int integer)
{
    HN_hnorm(varPtr); // head normalize, side effects pushing normalized term in AM_head AM_argVec AM_numargs
    varPtr = DF_termDeref(varPtr); // term deference, no side effects
    if (!DF_isFV(varPtr)) EM_error(BI_ERROR_NON_VAR_TERM, varPtr); // check free, throw error, need to access EM but can be handled by returning error code and throw error outside

    TR_trailTerm(varPtr); // heavily rely on AM
    DF_mkInt((MemPtr)varPtr, integer);
}



static void BIIO_bindVarToString(DF_TermPtr varPtr, char* str)
{
    // allocate a new string on the heap - side effects on heap
    MemPtr strDataHead = AM_hreg;
    MemPtr strData     = strDataHead + DF_STRDATA_HEAD_SIZE;
    MemPtr nhreg;
    int    length      = strlen(str);
    int    size        = MCSTR_numWords(length);

    nhreg = strData + size;
    AM_heapError(nhreg); // This checks heap overflow
    DF_mkStrDataHead(strDataHead);
    MCSTR_toString((MCSTR_Str)strData, str, length);
    AM_hreg = nhreg;

    // do the same work as bindvartoint
    HN_hnorm(varPtr);
    varPtr = DF_termDeref(varPtr);
    if (!DF_isFV(varPtr)) EM_error(BI_ERROR_NON_VAR_TERM, varPtr);

    TR_trailTerm(varPtr);
    DF_mkStr((MemPtr)varPtr, (DF_StrDataPtr)strDataHead);
}


/* Given an lpwam VAR term pointer, and a stream index,
   bind the variable term to the given stream. */
static void BIIO_bindVarToStream(DF_TermPtr varPtr, WordPtr stream)
{   MemPtr nhreg;

    HN_hnorm(varPtr);
    varPtr = DF_termDeref(varPtr);
    if (!DF_isFV(varPtr)) EM_error(BI_ERROR_NON_VAR_TERM, varPtr);

    TR_trailTerm(varPtr);
    //GN, bug fix on June 20, 2012. 
    //Pointers to file descriptors have to be globalized. 
    //Otherwise, they could end up in registers (via put_value,
    //for example) and then updating them, such as when closing 
    //a stream, will update the contents of the register and 
    //not have the required global effect.

    // allocate space for the stream
    nhreg = AM_hreg + DF_TM_ATOMIC_SIZE;
    AM_heapError(nhreg);
    DF_mkStream((MemPtr)AM_hreg,stream); 
    DF_mkRef((MemPtr)varPtr,(DF_TermPtr)AM_hreg); 
    AM_hreg = nhreg;
}

 calling TR_trailTerm: record addresses of variables that need to set unbound upon backtracking
 from a choice point
 
//          calling typesUnify       -  modifies PDL


//----------------------Weird errors----------------------
when including "abstmachine.h" in the shared library, it seems to share all the AM definitions
when dynamically loaded... But assignment on AMs behave stange inside .so
1. putting AM_preg = AM_cpreg inside .so the assignment does not work..
